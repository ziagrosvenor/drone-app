suite("Collective",function(){test("new Basic.Collective has no aspects or member functions",function(){var e=new Basic.Collective;assert.equal(e.aspects.length,0)}),test("assimilate aspect that doesn't yet belong to a collective",function(){var e=new Basic.Collective,t={contribute:{method:function(){}}};e.assimilate(t),assert.equal(e.aspects.length,1),assert.equal(e.aspects[0],t),assert.equal(t.collective,e)}),test("Collective constructor accepts a set of entities to assimilate",function(){var e={},t={},s=new Basic.Collective(e,t);assert.equal(s.aspects.length,2),assert.equal(s.aspects[0],e),assert.equal(s.aspects[1],t),assert.equal(e.collective,s),assert.equal(t.collective,s)}),test("assimilate collective",function(){var e={},t=new Basic.Collective(e),s={},a=new Basic.Collective(s);t.assimilate(a),assert.equal(t.aspects.length,2),assert.equal(t.aspects[0],e),assert.equal(t.aspects[1],s),assert.equal(e.collective,t),assert.equal(s.collective,t),assert.equal(a.aspects.length,0)}),test("assimilate aspect that already belongs to a collective",function(){var e={},t=new Basic.Collective(e),s={},a=new Basic.Collective(s);t.assimilate(s),assert.equal(t.aspects.length,2),assert.equal(t.aspects[0],e),assert.equal(t.aspects[1],s),assert.equal(e.collective,t),assert.equal(s.collective,t),assert.equal(a.aspects.length,0)}),test("assimilating aspect that's already in the same collective has no effect",function(){var e={},t=new Basic.Collective(e);assert.equal(t.aspects.length,1),t.assimilate(e),assert.equal(t.aspects.length,1)}),test("collective methods are union of assimilated aspect methods",function(){var e={contribute:{foo:function(){},bletch:function(){}}},t={contribute:{bar:function(){},bletch:function(){}}},s=new Basic.Collective(e,t),a=s.methods;assert.equal(a.foo.length,1),assert.equal(a.bar.length,1),assert.equal(a.bletch.length,2)}),test("collective method executes that method on all aspects that have it",function(){var e=[],t={contribute:{method:function(t){e.push("outermost "+t)}}},s={contribute:{}},a={contribute:{method:function(t){e.push("innermost "+t)}}},c=new Basic.Collective(t,s,a);assert.equal(c.methods.method.length,2),c.invokeMethod("method",["foo"]),assert.equal(e.length,2),assert.equal(e[0],"innermost foo"),assert.equal(e[1],"outermost foo")}),test("aspect's collectiveChanged handler invoked when collective changes",function(){var e=0,t={contribute:{collectiveChanged:function(){e++}}},s=new Basic.Collective(t);assert.equal(e,1);new Basic.Collective(s);assert.equal(e,2)}),test("collective decorates itself with all the collective's methods",function(){var e={contribute:{getName:function(e){return this.name+" "+e}},name:"aspect1"},t={contribute:{},name:"aspect2"},s=new Basic.Collective(e,t);assert.equal(s.getName("foo"),"aspect1 foo")}),test("collective getter invokes outermost aspect with that getter",function(){var e={contribute:{get value(){return 1}}},t={contribute:{get value(){return 2}}},s=new Basic.Collective(e,t);assert.equal(s.getters.value.length,2),assert.equal(s.value,1)}),test("collective setter invoke setters on all aspects that have it",function(){var e={contribute:{set value(e){c.push("outer "+e)}}},t={contribute:{set value(e){c.push("inner "+e)}}},s=new Basic.Collective(e,t),a=s.setters;assert.equal(a.value.length,2);var c=[];s.value="foo",assert.deepEqual(c,["inner foo","outer foo"])}),test("assimilating a class assimilates an instance of that class",function(){var e=function(){},t=new Basic.Collective(e);assert.isUndefined(e.collective);var s=t.aspects[0];assert.instanceOf(s,e)}),test("don't assimilate an aspect if one with the same 'name' key has already been assimilated",function(){var e={name:"Sample"},t={name:"Sample"},s=new Basic.Collective(e,t);assert.equal(s.aspects.length,1)}),test("aspect can define a default function for a collective method",function(){var e={contribute:{foo:Basic.Collective.defaultMethod}},t=new Basic.Collective(e);assert.equal(t.foo(),void 0);var s={contribute:{foo:function(){return"Hello"}}};t.assimilate(s),assert.equal(t.foo(),"Hello")})});